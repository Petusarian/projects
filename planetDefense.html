<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Planet Defense Game</title>
  <style>
  /* Overall container for a 1920x1080 view */
  #container {
  position: absolute;
  top: 0;
  left: 50%;
  width: 1920px;
  height: 1080px;
  background: #1A1F3B;
  transform: translateX(-50%) scale(var(--scale, 1));
  transform-origin: center top;
}

  /* Center the game canvas (1080x1080) */
  #gameCanvas {
    position: absolute;
    left: 420px;  /* (1920 - 1080)/2 = 420 */
    top: 0;
    width: 1080px;
    height: 1080px;
    background: #111;  /* remains unchanged */
    border: 2px solid #2E3B55; /* updated to a dark blue border */
  }
    body {
  margin: 0;
  background: #1A1F3B;
}
  /* Stats panel on the left (vertical list) */
  #ui {
    position: absolute;
    left: 0;
    top: 0;
    width: 420px;
    height: 1080px;
    background: #2E3B55; /* updated to a dark blue shade */
    color: #f0f0f0;
    padding: 20px;
    box-sizing: border-box;
    font-size: 18px;
    overflow-y: auto;
  }
  /* Upgrade menu on the right (vertical list) */
  #upgradeMenu {
    position: absolute;
    right: 0;
    top: 0;
    width: 420px;
    height: 1080px;
    background: rgba(26, 31, 59, 0.85); /* dark blue tint */
    color: #f0f0f0;
    padding: 20px;
    box-sizing: border-box;
    font-size: 18px;
    display: none;
    overflow-y: auto;
  }
  /* Overlay button (centered over the game canvas if needed) */
  #overlayButton {
    position: absolute;
    left: 50%;
    top: 20%;
    transform: translate(-50%, -50%);
    padding: 20px 30px;
    font-size: 20px;
    cursor: pointer;
    z-index: 20;
    display: none;
    background: #2E3B55; /* dark blue button background */
    border: 2px solid #3B4A6B;
    color: #f0f0f0;
    border-radius: 4px;
  }
    #upgradeMenu button {
  padding: 10px 20px;
  font-size: 20px;
  cursor: pointer;
  margin: 10px 0;
  background: #3B4A6B;
  border: 2px solid #3B4A6B;
  color: #f0f0f0;
  border-radius: 4px;
  transition: background 0.3s ease, transform 0.2s ease;
}
#upgradeMenu button:hover {
  background: #4A5A7A;
  transform: translateY(-2px);
}
</style>

</head>
<body>
  <div id="container">
    <div id="ui"></div>
    <canvas id="gameCanvas"></canvas>
    <div id="upgradeMenu">
      <h2>Upgrade Your Defenses</h2>
      <div id="shardDisplay"></div>
      <div id="upgradeOptions"></div>
      <button id="nextYearButton">Start Next Year</button>
    </div>
    <button id="overlayButton">Start Game</button>
  </div>
  <script>
    /****************** CONFIGURABLE PARAMETERS ******************/
    const config = {
      canvasWidth: 1080,
      canvasHeight: 1080,
      // Planet settings.
      planet: {
        radius: 50,
        maxHealth: 100,
        fragmentCount: 30,      // Number of fragments in explosion.
        fragmentLife: 4000,       // ms lifetime for fragments.
        fragmentSpeed: { min: 1, max: 3 } // Speed range for fragments.
      },
      // Moon settings.
      moon: {
        radius: 15,
        orbitRadius: 100,
        speed: 0.01
      },
      // Game progression.
      orbitsPerYear: 15,  // One orbit equals one "day".
      baseAsteroidSpawnInterval: 1200, // ms.
      minAsteroidSpawnInterval: 200,
      // Asteroid settings.
      asteroid: {
        speedRange: [0.5, 1.5],
        sizeRange: [15, 25]
      },
      // Reticle settings.
      reticle: {
        duration: 500, // ms.
        effectiveRadius: 40
      },
      // Debris settings.
      debris: {
        duration: 1000 // ms.
      },
      // Moon rebuild settings.
      rebuild: {
        requiredClicks: 10,
        duration: 15000 // ms allowed.
      },
      // Screen shake.
      shake: {
        asteroidHit: 10,
        planetHit: 20
      },
      // Explosion effect.
      explosion: {
        baseParticles: 20,
        planetHitMultiplier: 1.5
      },
      // Star settings.
      stars: {
        count: 100
      },
      // Comet settings.
      comet: {
        spawnProbability: 0.0005,
        speedRange: [4, 6],
        lengthRange: [30, 50],
        life: 2000
      },
      // Upgrade costs.
      upgrades: {
        restoreHealthCostPerPoint: 1,
        increaseMaxHealthCost: 100,
        increaseMaxHealthBonus: 20,
        buyShieldCost: 200,
        restoreShieldCost: 100,
        buyCannonCost: 150
      },
      // Cannon settings.
      cannon: {
        cooldownTime: 5000,    // ms delay between shots.
        range: 200,            // Targeting range.
        hitThreshold: 20,      // Impact detection radius for cannon destruction.
        targetingDelay: 400    // ms delay before firing after acquiring target.
      }
    };


	  // Preload custom asset images.
	const planetImg = new Image();
	planetImg.src = "assets/Terran.png";
	
	const moonImg = new Image();
	moonImg.src = "assets/Baren.png";
	
	const asteroidImg = new Image();
	asteroidImg.src = "assets/Asteroid 01 - Base.png";
	
	const explosionImg = new Image();
	explosionImg.src = "assets/Asteroid 01 - Explode.png";

	  
    /**************************************************************/

    // Canvas and UI setup.
    const canvas = document.getElementById("gameCanvas");
    canvas.width = config.canvasWidth;
    canvas.height = config.canvasHeight;
    const ctx = canvas.getContext("2d");
    const WIDTH = canvas.width;
    const HEIGHT = canvas.height;
    const overlayButton = document.getElementById("overlayButton");
    const upgradeMenu = document.getElementById("upgradeMenu");
    const shardDisplay = document.getElementById("shardDisplay");
    const upgradeOptionsDiv = document.getElementById("upgradeOptions");
    const nextYearButton = document.getElementById("nextYearButton");
    const uiDiv = document.getElementById("ui");

    // Game state variables.
    let gameState = "start";
    let currentYear = 1;
    let moonOrbitCount = 0;
    let asteroidSpawnInterval = config.baseAsteroidSpawnInterval;
    let score = 0;
    let shards = 0;

    // Screen shake.
    let shakeIntensity = 0;
    function updateShake(deltaTime) {
      shakeIntensity *= Math.pow(0.9, deltaTime / 16);
    }
    function applyShake() {
      if (shakeIntensity > 0.5) {
        const dx = (Math.random() - 0.5) * shakeIntensity;
        const dy = (Math.random() - 0.5) * shakeIntensity;
        ctx.translate(dx, dy);
      }
    }

    // Planet and health.
    const planet = { x: WIDTH / 2, y: HEIGHT / 2, radius: config.planet.radius };
    let planetMaxHealth = config.planet.maxHealth;
    let planetHealth = planetMaxHealth;

    // Moon.
    const moonOriginal = { 
      radius: config.moon.radius, 
      orbitRadius: config.moon.orbitRadius, 
      speed: config.moon.speed 
    };
    let moon = { 
      radius: moonOriginal.radius, 
      orbitRadius: moonOriginal.orbitRadius, 
      angle: 0, 
      speed: moonOriginal.speed 
    };
    let previousMoonAngle = moon.angle;

    // Moon rebuild tracking.
    let moonRebuildProgress = 0;
    let moonRebuildTime = 0;

    // Shield and cannons.
    let shield = null; // When purchased: { health, maxHealth, cannons: [] }
    const shieldOffset = 80;

    // Collections.
    const asteroids = [];
    const debrisPieces = [];
    const reticles = [];
    const explosions = [];
    const stars = [];
    const comets = [];
    let planetFragments = [];

    let lastTime = 0;
    let asteroidTimer = 0;

    // Create stars.
    for (let i = 0; i < config.stars.count; i++) {
      stars.push({
        x: Math.random() * WIDTH,
        y: Math.random() * HEIGHT,
        brightness: Math.random() * 0.5 + 0.5,
        flickerSpeed: Math.random() * 0.005 + 0.002
      });
    }

    // Helper: random.
    function random(min, max) {
      return Math.random() * (max - min) + min;
    }

    // Generate asteroid shape.
    function generateAsteroidShape(radius) {
      const points = [];
      const numPoints = Math.floor(random(6, 10));
      for (let i = 0; i < numPoints; i++) {
        const angle = (i / numPoints) * Math.PI * 2;
        const r = radius * random(0.7, 1.3);
        points.push({ x: r * Math.cos(angle), y: r * Math.sin(angle) });
      }
      return points;
    }

    // Spawn asteroid.
    function spawnAsteroid() {
      const edge = Math.floor(random(0, 4));
      let x, y;
      if (edge === 0) { x = random(-50, WIDTH + 50); y = -50; }
      else if (edge === 1) { x = WIDTH + 50; y = random(-50, HEIGHT + 50); }
      else if (edge === 2) { x = random(-50, WIDTH + 50); y = HEIGHT + 50; }
      else { x = -50; y = random(-50, HEIGHT + 50); }
      const dx = planet.x - x;
      const dy = planet.y - y;
      const angle = Math.atan2(dy, dx);
      const speed = random(config.asteroid.speedRange[0], config.asteroid.speedRange[1]);
      const baseRadius = random(config.asteroid.sizeRange[0], config.asteroid.sizeRange[1]);
      asteroids.push({
        x, y,
        radius: baseRadius,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        shape: generateAsteroidShape(baseRadius),
        angle: random(0, Math.PI * 2),
        angularVelocity: random(-0.02, 0.02)
      });
    }

    // Add reticle.
    function addReticle(x, y) {
      reticles.push({ x, y, elapsed: 0, duration: config.reticle.duration });
    }

    // Shatter asteroid.
    function shatterAsteroid(asteroid) {
      shakeIntensity += config.shake.asteroidHit;
      score += 10;
      shards += 10;
      const numFragments = Math.floor(random(3, 7));
      for (let i = 0; i < numFragments; i++) {
        debrisPieces.push({
          x: asteroid.x,
          y: asteroid.y,
          vx: asteroid.vx + random(-1, 1),
          vy: asteroid.vy + random(-1, 1),
          shape: asteroid.shape,
          angle: asteroid.angle,
          angularVelocity: asteroid.angularVelocity + random(-0.05, 0.05),
          scale: 1,
          duration: config.debris.duration,
          elapsed: 0
        });
      }
    }

    // Explosion effect.
    function createExplosion(x, y, power = 1) {
      const numParticles = Math.floor(config.explosion.baseParticles * power);
      for (let i = 0; i < numParticles; i++) {
        explosions.push({
          x, y,
          vx: random(-3, 3) * power,
          vy: random(-3, 3) * power,
          radius: random(2, 4) * power,
          life: random(500, 1000),
          elapsed: 0,
          color: "#f39c12"
        });
      }
    }

    // Generate planet fragments.
    function generatePlanetFragments() {
      planetFragments = [];
      for (let i = 0; i < config.planet.fragmentCount; i++) {
        const angle = random(0, Math.PI * 2);
        const speed = random(config.planet.fragmentSpeed.min, config.planet.fragmentSpeed.max);
        planetFragments.push({
          x: planet.x,
          y: planet.y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          radius: random(5, 15),
          life: config.planet.fragmentLife,
          elapsed: 0,
          angle: angle,
          angularVelocity: random(-0.05, 0.05)
        });
      }
    }

    // Update planet fragments.
    function updatePlanetFragments(deltaTime) {
      for (let i = planetFragments.length - 1; i >= 0; i--) {
        const frag = planetFragments[i];
        frag.x += frag.vx;
        frag.y += frag.vy;
        frag.angle += frag.angularVelocity;
        frag.elapsed += deltaTime;
        if (frag.elapsed > frag.life) {
          planetFragments.splice(i, 1);
        }
      }
    }

    // Draw planet fragments.
    function drawPlanetFragments() {
      planetFragments.forEach(frag => {
        const alpha = 1 - (frag.elapsed / frag.life);
        ctx.save();
        ctx.translate(frag.x, frag.y);
        ctx.rotate(frag.angle);
        ctx.globalAlpha = alpha;
        ctx.fillStyle = "#3498db";
        ctx.beginPath();
        ctx.arc(0, 0, frag.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      });
    }

    // Update explosion particles.
    function updateExplosions(deltaTime) {
      for (let i = explosions.length - 1; i >= 0; i--) {
        const p = explosions[i];
        p.x += p.vx;
        p.y += p.vy;
        p.elapsed += deltaTime;
        if (p.elapsed >= p.life) {
          explosions.splice(i, 1);
        }
      }
    }
    // Draw explosion particles.
    function drawExplosions() {
  explosions.forEach(p => {
    const alpha = 1 - (p.elapsed / p.life);
    const frameCount = 8; // Assuming 8 frames in the sprite sheet.
    if (!explosionImg.complete) return;
    const frameWidth = explosionImg.width / frameCount;
    let frame = Math.floor((p.elapsed / p.life) * frameCount);
    if (frame >= frameCount) frame = frameCount - 1;
    ctx.save();
    ctx.globalAlpha = alpha;
    // Draw the selected explosion frame centered at (p.x, p.y)
    ctx.drawImage(
      explosionImg,
      frame * frameWidth, 0, 
      frameWidth, explosionImg.height,
      p.x - frameWidth / 2, p.y - explosionImg.height / 2,
      frameWidth, explosionImg.height
    );
    ctx.restore();
  });
}


    // Update stars.
    function updateStars(deltaTime) {
      stars.forEach(star => {
        star.brightness += star.flickerSpeed * deltaTime;
        if (star.brightness > 1 || star.brightness < 0.5) {
          star.flickerSpeed *= -1;
        }
      });
    }
    // Draw stars.
    function drawStars() {
      stars.forEach(star => {
        ctx.save();
        ctx.globalAlpha = star.brightness;
        ctx.fillStyle = "#fff";
        ctx.fillRect(star.x, star.y, 2, 2);
        ctx.restore();
      });
    }

    // Comet functions.
    function maybeSpawnComet(deltaTime) {
      if (Math.random() < config.comet.spawnProbability) {
        comets.push({
          x: -50,
          y: random(0, HEIGHT / 2),
          vx: random(config.comet.speedRange[0], config.comet.speedRange[1]),
          vy: random(1, 3),
          length: random(config.comet.lengthRange[0], config.comet.lengthRange[1]),
          life: config.comet.life,
          elapsed: 0
        });
      }
    }
    function updateComets(deltaTime) {
      maybeSpawnComet(deltaTime);
      for (let i = comets.length - 1; i >= 0; i--) {
        const c = comets[i];
        c.x += c.vx;
        c.y += c.vy;
        c.elapsed += deltaTime;
        if (c.elapsed >= c.life || c.x > WIDTH + 50) {
          comets.splice(i, 1);
        }
      }
    }
    function drawComets() {
      comets.forEach(c => {
        const alpha = 1 - (c.elapsed / c.life);
        ctx.save();
        ctx.globalAlpha = alpha * 0.3;
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(c.x, c.y);
        ctx.lineTo(c.x - c.length, c.y - c.length * 0.5);
        ctx.stroke();
        ctx.restore();
      });
    }

    // Draw shield.
    function drawShield() {
      if (shield) {
        const shieldRadius = planet.radius + shieldOffset;
        ctx.save();
        ctx.strokeStyle = "#00ffff";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(planet.x, planet.y, shieldRadius, 0, Math.PI * 2);
        ctx.stroke();
        const shieldHealthPercent = shield.health / shield.maxHealth;
        ctx.font = "16px sans-serif";
        ctx.fillStyle = "#00ffff";
        ctx.textAlign = "center";
        ctx.fillText(`Shield: ${(shieldHealthPercent * 100).toFixed(0)}%`, planet.x, planet.y + shieldRadius + 20);
        ctx.restore();
      }
    }

    // Update cannons with exclusive targeting.
    function updateCannons(deltaTime) {
      if (shield && shield.cannons) {
        shield.cannons.forEach(cannon => {
          cannon.cooldown -= deltaTime;
          const shieldRadius = planet.radius + shieldOffset;
          cannon.x = planet.x + shieldRadius * Math.cos(cannon.angle);
          cannon.y = planet.y + shieldRadius * Math.sin(cannon.angle);
          if (cannon.cooldown <= 0) {
            if (!cannon.target) {
              let nearest = null;
              let nearestDist = Infinity;
              for (let i = 0; i < asteroids.length; i++) {
                const a = asteroids[i];
                let alreadyTargeted = false;
                shield.cannons.forEach(other => {
                  if (other !== cannon && other.target === a) {
                    alreadyTargeted = true;
                  }
                });
                if (alreadyTargeted) continue;
                const dist = Math.hypot(cannon.x - a.x, cannon.y - a.y);
                if (dist < config.cannon.range && dist < nearestDist) {
                  nearest = a;
                  nearestDist = dist;
                }
              }
              if (nearest) {
                cannon.target = nearest;
                cannon.targetTime = 0;
              }
            } else {
              cannon.targetTime += deltaTime;
              if (cannon.targetTime >= config.cannon.targetingDelay) {
                const dist = Math.hypot(cannon.x - cannon.target.x, cannon.y - cannon.target.y);
                if (dist < config.cannon.range) {
                  shatterAsteroid(cannon.target);
                  for (let i = 0; i < asteroids.length; i++) {
                    if (asteroids[i] === cannon.target) {
                      asteroids.splice(i, 1);
                      break;
                    }
                  }
                  cannon.cooldown = config.cannon.cooldownTime;
                }
                cannon.target = null;
              }
            }
          }
        });
      }
    }
    function drawCannons() {
      if (shield && shield.cannons) {
        shield.cannons.forEach(cannon => {
          ctx.save();
          ctx.globalAlpha = (cannon.cooldown > 0) ? 0.5 : 1;
          ctx.fillStyle = "#ff0";
          ctx.beginPath();
          ctx.arc(cannon.x, cannon.y, 5, 0, Math.PI * 2);
          ctx.fill();
          if (cannon.target && cannon.targetTime < config.cannon.targetingDelay) {
            ctx.strokeStyle = "#ff0";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(cannon.x, cannon.y);
            ctx.lineTo(cannon.target.x, cannon.target.y);
            ctx.stroke();
          }
          ctx.restore();
        });
      }
    }

    // Draw planet.
    function drawPlanet() {
      if (gameState !== "exploding" && gameState !== "gameover") {
    // Draw the planet image centered at planet.x, planet.y.
    ctx.drawImage(planetImg, planet.x - planet.radius, planet.y - planet.radius, planet.radius * 2, planet.radius * 2);
  }
  // (Keep the health bar drawing code unchanged below.)
  const barWidth = 80, barHeight = 10;
  const healthPercent = planetHealth / planetMaxHealth;
  ctx.fillStyle = "#e74c3c";
  ctx.fillRect(planet.x - barWidth/2, planet.y - planet.radius - 20, barWidth * healthPercent, barHeight);
  ctx.strokeStyle = "#fff";
  ctx.strokeRect(planet.x - barWidth/2, planet.y - planet.radius - 20, barWidth, barHeight);
      if (gameState === "moonRebuild") {
        const rebuildBarWidth = 80, rebuildBarHeight = 10;
        const progress = moonRebuildProgress / config.rebuild.requiredClicks;
        ctx.fillStyle = "#2ecc71";
        ctx.fillRect(planet.x - rebuildBarWidth/2, planet.y - planet.radius - 40, rebuildBarWidth * progress, rebuildBarHeight);
        ctx.strokeStyle = "#fff";
        ctx.strokeRect(planet.x - rebuildBarWidth/2, planet.y - planet.radius - 40, rebuildBarWidth, rebuildBarHeight);
        const timeLeft = Math.max(0, config.rebuild.duration - moonRebuildTime);
        const secondsLeft = (timeLeft / 1000).toFixed(1);
        ctx.font = "16px sans-serif";
        ctx.fillStyle = "#fff";
        ctx.textAlign = "center";
        ctx.fillText(`Time: ${secondsLeft}s`, planet.x, planet.y - planet.radius - 50);
      }
      drawShield();
    }

    // Draw moon.
    function drawMoon() {
  if (gameState !== "moonRebuild" && gameState !== "exploding" && gameState !== "gameover") {
    const moonX = planet.x + moon.orbitRadius * Math.cos(moon.angle);
    const moonY = planet.y + moon.orbitRadius * Math.sin(moon.angle);
    // Draw the moon image (using the custom Baren image).
    ctx.drawImage(moonImg, moonX - moon.radius, moonY - moon.radius, moon.radius * 2, moon.radius * 2);
  }
}


    // Draw asteroids.
    function drawAsteroids() {
  const scaleFactor = 3; // Adjust this multiplier as needed.
  asteroids.forEach(asteroid => {
    ctx.save();
    ctx.translate(asteroid.x, asteroid.y);
    ctx.rotate(asteroid.angle);
    // Multiply the asteroid radius by scaleFactor for a larger image.
    ctx.drawImage(
      asteroidImg,
      -asteroid.radius * scaleFactor, 
      -asteroid.radius * scaleFactor, 
      asteroid.radius * 2 * scaleFactor, 
      asteroid.radius * 2 * scaleFactor
    );
    ctx.restore();
  });
}


    // Update asteroids.
    function updateAsteroids(deltaTime) {
      for (let i = asteroids.length - 1; i >= 0; i--) {
        const a = asteroids[i];
        a.x += a.vx;
        a.y += a.vy;
        a.angle += a.angularVelocity;
        if (a.x < -100 || a.x > WIDTH + 100 || a.y < -100 || a.y > HEIGHT + 100) {
          asteroids.splice(i, 1);
        }
      }
    }

    // Update debris.
    function updateDebris(deltaTime) {
      for (let i = debrisPieces.length - 1; i >= 0; i--) {
        const d = debrisPieces[i];
        d.x += d.vx;
        d.y += d.vy;
        d.angle += d.angularVelocity;
        d.elapsed += deltaTime;
        d.scale = Math.max(1 - d.elapsed / d.duration, 0);
        if (d.elapsed >= d.duration) {
          debrisPieces.splice(i, 1);
        }
      }
    }
    function drawDebris() {
      debrisPieces.forEach(d => {
        ctx.save();
        ctx.translate(d.x, d.y);
        ctx.rotate(d.angle);
        ctx.scale(d.scale, d.scale);
        ctx.beginPath();
        ctx.moveTo(d.shape[0].x, d.shape[0].y);
        for (let i = 1; i < d.shape.length; i++) {
          ctx.lineTo(d.shape[i].x, d.shape[i].y);
        }
        ctx.closePath();
        ctx.fillStyle = "#e74c3c";
        ctx.fill();
        ctx.restore();
      });
    }

    // Update reticles.
    function updateReticles(deltaTime) {
      for (let i = reticles.length - 1; i >= 0; i--) {
        const r = reticles[i];
        r.elapsed += deltaTime;
        if (r.elapsed > r.duration) {
          reticles.splice(i, 1);
        }
      }
    }
    function drawReticles() {
      reticles.forEach(r => {
        const progress = r.elapsed / r.duration;
        const radius = 10 + progress * 50;
        const alpha = 1 - progress;
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.beginPath();
        ctx.arc(r.x, r.y, radius, 0, Math.PI * 2);
        ctx.strokeStyle = "#f1c40f";
        ctx.lineWidth = 3;
        ctx.stroke();
        ctx.restore();
      });
    }

    // Update the moon.
    function updateMoon(deltaTime) {
      if (gameState === "playing") {
        previousMoonAngle = moon.angle;
        moon.angle += moon.speed;
        if (moon.angle >= Math.PI * 2) { moon.angle -= Math.PI * 2; }
        if (previousMoonAngle > moon.angle) {
          moonOrbitCount++;
          if (moonOrbitCount >= config.orbitsPerYear) {
            gameState = "yearEnd";
            showUpgradeMenu();
          }
        }
      }
    }

    // Check collisions.
    function checkCollisions() {
      let moonX, moonY;
      if (gameState !== "moonRebuild") {
        moonX = planet.x + moon.orbitRadius * Math.cos(moon.angle);
        moonY = planet.y + moon.orbitRadius * Math.sin(moon.angle);
      }
      for (let i = asteroids.length - 1; i >= 0; i--) {
        const a = asteroids[i];
        const distToPlanet = Math.hypot(a.x - planet.x, a.y - planet.y);
        // Shield collision.
        if (shield) {
          const shieldRadius = planet.radius + shieldOffset;
          if (distToPlanet < shieldRadius + a.radius && distToPlanet >= planet.radius) {
            shield.health -= a.radius;
            if (shield.health <= 0) {
              shield = null;
            } else if (shield.cannons) {
              shield.cannons = shield.cannons.filter(cannon => {
                const d = Math.hypot(cannon.x - a.x, cannon.y - a.y);
                return d >= config.cannon.hitThreshold;
              });
            }
            createExplosion(a.x, a.y, config.explosion.planetHitMultiplier);
            shakeIntensity += config.shake.planetHit;
            asteroids.splice(i, 1);
            continue;
          }
        }
        // Planet collision.
        if (distToPlanet < planet.radius + a.radius) {
          if (shield) {
            shield.health -= a.radius;
            if (shield.health <= 0) {
              shield = null;
            }
          } else {
            planetHealth -= a.radius;
          }
          createExplosion(a.x, a.y, config.explosion.planetHitMultiplier);
          shakeIntensity += config.shake.planetHit;
          asteroids.splice(i, 1);
          continue;
        }
        // Moon collision.
        if (gameState !== "moonRebuild") {
          const distToMoon = Math.hypot(a.x - moonX, a.y - moonY);
          if (distToMoon < moon.radius + a.radius) {
            gameState = "moonRebuild";
            moonRebuildTime = 0;
            moonRebuildProgress = 0;
            asteroids.splice(i, 1);
            break;
          }
        }
      }
      if (planetHealth <= 0 && gameState !== "exploding") {
        gameState = "exploding";
        asteroids.length = 0;
        generatePlanetFragments();
      }
    }

    // Update cannons.
    function updateCannons(deltaTime) {
      if (shield && shield.cannons) {
        shield.cannons.forEach(cannon => {
          cannon.cooldown -= deltaTime;
          const shieldRadius = planet.radius + shieldOffset;
          cannon.x = planet.x + shieldRadius * Math.cos(cannon.angle);
          cannon.y = planet.y + shieldRadius * Math.sin(cannon.angle);
          if (cannon.cooldown <= 0) {
            if (!cannon.target) {
              let nearest = null;
              let nearestDist = Infinity;
              for (let i = 0; i < asteroids.length; i++) {
                const a = asteroids[i];
                let alreadyTargeted = false;
                shield.cannons.forEach(other => {
                  if (other !== cannon && other.target === a) {
                    alreadyTargeted = true;
                  }
                });
                if (alreadyTargeted) continue;
                const dist = Math.hypot(cannon.x - a.x, cannon.y - a.y);
                if (dist < config.cannon.range && dist < nearestDist) {
                  nearest = a;
                  nearestDist = dist;
                }
              }
              if (nearest) {
                cannon.target = nearest;
                cannon.targetTime = 0;
              }
            } else {
              cannon.targetTime += deltaTime;
              if (cannon.targetTime >= config.cannon.targetingDelay) {
                const dist = Math.hypot(cannon.x - cannon.target.x, cannon.y - cannon.target.y);
                if (dist < config.cannon.range) {
                  shatterAsteroid(cannon.target);
                  for (let i = 0; i < asteroids.length; i++) {
                    if (asteroids[i] === cannon.target) {
                      asteroids.splice(i, 1);
                      break;
                    }
                  }
                  cannon.cooldown = config.cannon.cooldownTime;
                }
                cannon.target = null;
              }
            }
          }
        });
      }
    }
    function drawCannons() {
      if (shield && shield.cannons) {
        shield.cannons.forEach(cannon => {
          ctx.save();
          ctx.globalAlpha = (cannon.cooldown > 0) ? 0.5 : 1;
          ctx.fillStyle = "#ff0";
          ctx.beginPath();
          ctx.arc(cannon.x, cannon.y, 5, 0, Math.PI * 2);
          ctx.fill();
          if (cannon.target && cannon.targetTime < config.cannon.targetingDelay) {
            ctx.strokeStyle = "#ff0";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(cannon.x, cannon.y);
            ctx.lineTo(cannon.target.x, cannon.target.y);
            ctx.stroke();
          }
          ctx.restore();
        });
      }
    }
	
		function updateScale() {
	  // Calculate scale based on window dimensions. You might choose the smaller of the two ratios.
	  const scale = Math.min(window.innerWidth / 1920, window.innerHeight / 1080);
	  document.documentElement.style.setProperty('--scale', scale);
	}
	updateScale();
	window.addEventListener('resize', updateScale);
	
    // Main game loop.
    function gameLoop(timestamp) {
      const deltaTime = timestamp - lastTime;
      lastTime = timestamp;
      updateShake(deltaTime);

      if (gameState === "playing" || gameState === "moonRebuild") {
        asteroidTimer += deltaTime;
        if (asteroidTimer > asteroidSpawnInterval) {
          spawnAsteroid();
          asteroidTimer = 0;
        }
        updateAsteroids(deltaTime);
        updateDebris(deltaTime);
        updateReticles(deltaTime);
        updateExplosions(deltaTime);
        updateComets(deltaTime);
        updateMoon(deltaTime);
        checkCollisions();
        updateCannons(deltaTime);
        if (gameState === "moonRebuild") {
          moonRebuildTime += deltaTime;
          if (moonRebuildTime > config.rebuild.duration) {
            planetHealth = 0;
            gameState = "exploding";
            asteroids.length = 0;
            generatePlanetFragments();
          }
        }
      }
      
      ctx.save();
      applyShake();
      ctx.clearRect(0, 0, WIDTH, HEIGHT);
      
      drawStars();
      drawComets();
      
      if (gameState === "exploding") {
        updatePlanetFragments(deltaTime);
        drawPlanetFragments();
        if (planetFragments.length === 0) {
          gameState = "gameover";
          overlayButton.textContent = "Game Over - Restart";
          overlayButton.style.display = "block";
        }
      } else {
        drawPlanet();
        drawMoon();
        if (shield) drawShield();
      }
      drawAsteroids();
      drawDebris();
      drawExplosions();
      drawReticles();
      if (shield && shield.cannons) drawCannons();
      ctx.restore();
      
      uiDiv.innerHTML = `Year: ${currentYear}<br>Day: ${moonOrbitCount} / ${config.orbitsPerYear}<br>Health: ${Math.max(planetHealth, 0).toFixed(0)}<br>Shards: ${shards}<br>Score: ${score}${gameState === "moonRebuild" ? "<br>Rebuild: " + moonRebuildProgress + "/" + config.rebuild.requiredClicks : ""}`;
      
      requestAnimationFrame(gameLoop);
    }
    requestAnimationFrame(gameLoop);

    // Upgrade Menu Functions.
    function showUpgradeMenu() {
      gameState = "upgrading";
      upgradeMenu.style.display = "block";
      updateUpgradeMenu();
    }
    function updateUpgradeMenu() {
      shardDisplay.innerHTML = `<p>Shards: ${shards}</p>`;
      let optionsHTML = "";
      const missingHealth = planetMaxHealth - planetHealth;
      const restoreCost = missingHealth * config.upgrades.restoreHealthCostPerPoint;
      optionsHTML += `<button onclick="upgradeRestoreHealth()">Restore Health (${restoreCost} Shards)</button><br>`;
      optionsHTML += `<button onclick="upgradeIncreaseMaxHealth()">Increase Max Health (+${config.upgrades.increaseMaxHealthBonus}) (Cost: ${config.upgrades.increaseMaxHealthCost} Shards)</button><br>`;
      if (!shield) {
        optionsHTML += `<button onclick="upgradeBuyShield()">Buy Shield (Cost: ${config.upgrades.buyShieldCost} Shards)</button><br>`;
      } else {
        optionsHTML += `<button onclick="upgradeRestoreShield()">Restore Shield (Cost: ${config.upgrades.restoreShieldCost} Shards)</button><br>`;
        optionsHTML += `<button onclick="upgradeBuyCannon()">Buy Cannon (Cost: ${config.upgrades.buyCannonCost} Shards)</button><br>`;
      }
      upgradeOptionsDiv.innerHTML = optionsHTML;
    }

    // Upgrade functions.
    function upgradeRestoreHealth() {
      const missingHealth = planetMaxHealth - planetHealth;
      const cost = missingHealth * config.upgrades.restoreHealthCostPerPoint;
      if (shards >= cost && missingHealth > 0) {
        shards -= cost;
        planetHealth = planetMaxHealth;
        updateUpgradeMenu();
      }
    }
    function upgradeIncreaseMaxHealth() {
      if (shards >= config.upgrades.increaseMaxHealthCost) {
        shards -= config.upgrades.increaseMaxHealthCost;
        planetMaxHealth += config.upgrades.increaseMaxHealthBonus;
        planetHealth = planetMaxHealth;
        updateUpgradeMenu();
      }
    }
    function upgradeBuyShield() {
      if (shards >= config.upgrades.buyShieldCost) {
        shards -= config.upgrades.buyShieldCost;
        shield = { health: 100, maxHealth: 100, cannons: [] };
        updateUpgradeMenu();
      }
    }
    function upgradeRestoreShield() {
      if (shield && shards >= config.upgrades.restoreShieldCost) {
        shards -= config.upgrades.restoreShieldCost;
        shield.health = shield.maxHealth;
        updateUpgradeMenu();
      }
    }
    function upgradeBuyCannon() {
      if (shield && shards >= config.upgrades.buyCannonCost) {
        shards -= config.upgrades.buyCannonCost;
        const cannon = { angle: random(0, Math.PI * 2), cooldown: 0, x: 0, y: 0, target: null, targetTime: 0 };
        shield.cannons.push(cannon);
        const count = shield.cannons.length;
        shield.cannons.forEach((c, i) => {
          c.angle = (i / count) * Math.PI * 2;
        });
        updateUpgradeMenu();
      }
    }

    // Handle canvas clicks.
    canvas.addEventListener("click", function(e) {
  const rect = canvas.getBoundingClientRect();
  // Get the current scale from the CSS variable.
  const scale = parseFloat(getComputedStyle(document.documentElement)
                      .getPropertyValue('--scale')) || 1;
  // Adjust mouse coordinates to the unscaled canvas coordinate system.
  const clickX = (e.clientX - rect.left) / scale;
  const clickY = (e.clientY - rect.top) / scale;
  
  addReticle(clickX, clickY);
  
  if (gameState === "playing" || gameState === "moonRebuild") {
    for (let i = asteroids.length - 1; i >= 0; i--) {
      const a = asteroids[i];
      if (Math.hypot(clickX - a.x, clickY - a.y) < config.reticle.effectiveRadius) {
        shatterAsteroid(a);
        asteroids.splice(i, 1);
        break;
      }
    }
  }
  if (gameState === "moonRebuild") {
    if (Math.hypot(clickX - planet.x, clickY - planet.y) < planet.radius) {
      moonRebuildProgress++;
      if (moonRebuildProgress >= config.rebuild.requiredClicks) {
        gameState = "playing";
      }
    }
  }
});

    // Overlay / Upgrade Menu button handling.
    overlayButton.addEventListener("click", function() {
      if (gameState === "start" || gameState === "gameover") {
        currentYear = 1;
        planetMaxHealth = config.planet.maxHealth;
        planetHealth = planetMaxHealth;
        moon = { radius: moonOriginal.radius, orbitRadius: moonOriginal.orbitRadius, angle: 0, speed: moonOriginal.speed };
        moonOrbitCount = 0;
        asteroids.length = 0;
        debrisPieces.length = 0;
        reticles.length = 0;
        explosions.length = 0;
        comets.length = 0;
        planetFragments.length = 0;
        asteroidSpawnInterval = config.baseAsteroidSpawnInterval;
        score = 0;
        shards = 0;
        shield = null;
        gameState = "playing";
        overlayButton.style.display = "none";
        upgradeMenu.style.display = "none";
      }
    });
    nextYearButton.addEventListener("click", function() {
      currentYear++;
      moonOrbitCount = 0;
      asteroids.length = 0;
      debrisPieces.length = 0;
      reticles.length = 0;
      explosions.length = 0;
      comets.length = 0;
      planetFragments.length = 0;
      asteroidSpawnInterval = Math.max(config.minAsteroidSpawnInterval, config.baseAsteroidSpawnInterval - (currentYear - 1) * 100);
      gameState = "playing";
      upgradeMenu.style.display = "none";
    });

    // Initially show the Start Game button.
    overlayButton.style.display = "block";
  </script>
</body>
</html>
