<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Enhanced Browser Shooter</title>
  <style>
    body { margin: 0; overflow: hidden; background: #222; }
    canvas { display: block; margin: 0 auto; background: #444; }
    #info { color: white; text-align: center; font-family: sans-serif; }
  </style>
</head>
<body>
  <div id="info">
    <h1>Enhanced Browser Shooter</h1>
    <p>Click to shoot. Press Space to reload ammo.</p>
  </div>
  <canvas id="gameCanvas" width="800" height="400"></canvas>
  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    // Game settings
    let baseHealth = 100;
    const maxAmmo = 10;
    let ammo = maxAmmo;
    const reloadTime = 2000; // milliseconds
    let isReloading = false;

    let day = 1;
    const maxDays = 5;
    let enemiesToSpawn = day * 5; // number of enemies per wave increases each day
    let enemiesSpawned = 0;

    let bullets = [];
    let enemies = [];

    const bulletSpeed = 4;
    const enemySpeed = 0.8;  // slower enemy movement

    // Player base position and size
    const base = {
      x: canvas.width - 100,
      y: canvas.height / 2 - 40,
      width: 80,
      height: 80
    };

    // Mouse click to shoot (if not reloading and ammo available)
    canvas.addEventListener("click", (e) => {
      if (isReloading || ammo <= 0) return;
      const rect = canvas.getBoundingClientRect();
      const clickX = e.clientX - rect.left;
      const clickY = e.clientY - rect.top;
      const angle = Math.atan2(clickY - (base.y + base.height / 2), clickX - (base.x + base.width / 2));
      bullets.push({
        x: base.x + base.width / 2,
        y: base.y + base.height / 2,
        angle: angle
      });
      ammo--;
    });

    // Listen for spacebar to reload ammo
    window.addEventListener("keydown", (e) => {
      if (e.code === "Space" && !isReloading && ammo < maxAmmo) {
        isReloading = true;
        setTimeout(() => {
          ammo = maxAmmo;
          isReloading = false;
        }, reloadTime);
      }
    });

    // Function to spawn an enemy at a random vertical position on the left
    function spawnEnemy() {
      enemies.push({
        x: -50,
        y: Math.random() * (canvas.height - 40),
        width: 40,
        height: 40,
        health: 1
      });
      enemiesSpawned++;
    }

    // Update game state
    function update(deltaTime) {
      // Update bullets: move and remove if out of bounds
      bullets = bullets.filter(bullet => bullet.x < canvas.width && bullet.y > 0 && bullet.y < canvas.height);
      bullets.forEach(bullet => {
        bullet.x += bulletSpeed * Math.cos(bullet.angle);
        bullet.y += bulletSpeed * Math.sin(bullet.angle);
      });

      // Spawn enemies until the wave quota is reached
      if (enemiesSpawned < enemiesToSpawn) {
        // spawn an enemy every 1.5 seconds
        if (Date.now() - lastEnemySpawn > 1500) {
          spawnEnemy();
          lastEnemySpawn = Date.now();
        }
      }

      // Update enemies: move them toward the base
      enemies.forEach((enemy, index) => {
        enemy.x += enemySpeed;
        // If enemy reaches the base, damage the base
        if (enemy.x + enemy.width > base.x) {
          baseHealth -= 10;  // each enemy does 10 damage
          enemies.splice(index, 1);
        }
      });

      // Collision detection: bullet hits enemy
      bullets.forEach((bullet, bi) => {
        enemies.forEach((enemy, ei) => {
          if (bullet.x > enemy.x && bullet.x < enemy.x + enemy.width &&
              bullet.y > enemy.y && bullet.y < enemy.y + enemy.height) {
            // Remove enemy and bullet upon collision
            enemies.splice(ei, 1);
            bullets.splice(bi, 1);
          }
        });
      });

      // If wave is cleared and no more enemies are coming, advance day/wave
      if (enemies.length === 0 && enemiesSpawned >= enemiesToSpawn) {
        if (day < maxDays) {
          day++;
          enemiesToSpawn = day * 5;
          enemiesSpawned = 0;
        } else {
          // Game won after maxDays waves cleared
          gameWon = true;
        }
      }
    }

    // Render game objects and UI
    function draw() {
      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw base (green rectangle)
      ctx.fillStyle = "#00AA00";
      ctx.fillRect(base.x, base.y, base.width, base.height);

      // Draw bullets (yellow circles)
      ctx.fillStyle = "#FFFF00";
      bullets.forEach(bullet => {
        ctx.beginPath();
        ctx.arc(bullet.x, bullet.y, 5, 0, Math.PI * 2);
        ctx.fill();
      });

      // Draw enemies (red squares)
      ctx.fillStyle = "#FF0000";
      enemies.forEach(enemy => {
        ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
      });

      // Draw UI text
      ctx.fillStyle = "#FFFFFF";
      ctx.font = "18px sans-serif";
      ctx.fillText("Base Health: " + baseHealth, 20, 30);
      ctx.fillText("Ammo: " + ammo + (isReloading ? " (Reloading...)" : ""), 20, 60);
      ctx.fillText("Day: " + day + " / " + maxDays, 20, 90);

      if (baseHealth <= 0) {
        ctx.fillStyle = "#FF0000";
        ctx.font = "40px sans-serif";
        ctx.fillText("GAME OVER", canvas.width / 2 - 100, canvas.height / 2);
      } else if (gameWon) {
        ctx.fillStyle = "#00FF00";
        ctx.font = "40px sans-serif";
        ctx.fillText("YOU WIN!", canvas.width / 2 - 100, canvas.height / 2);
      }
    }

    // Main game loop variables
    let lastTime = 0;
    let lastEnemySpawn = Date.now();
    let gameWon = false;

    function gameLoop(timestamp) {
      const deltaTime = timestamp - lastTime;
      lastTime = timestamp;
      if (baseHealth > 0 && !gameWon) {
        update(deltaTime);
      }
      draw();
      requestAnimationFrame(gameLoop);
    }

    // Start the game loop
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
