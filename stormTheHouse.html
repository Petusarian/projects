<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Enhanced Browser Shooter – Upgrades & UI</title>
  <style>
    body { margin: 0; overflow: hidden; background: #222; }
    #gameContainer { position: relative; width: 1280px; margin: 0 auto; }
    canvas { 
      display: block; 
      background: #444; 
      cursor: crosshair; /* Reticle */
    }
    #startScreen {
      position: absolute;
      top: 0;
      left: 0;
      width: 1280px;
      height: 720px;
      background: rgba(0, 0, 0, 0.85);
      color: #fff;
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 2;
      text-align: center;
      padding: 20px;
    }
    #startButton {
      padding: 10px 20px;
      font-size: 24px;
      cursor: pointer;
      margin-top: 20px;
    }
    /* Upgrade menu overlay */
    #upgradeMenu {
      display: none;
      position: absolute;
      top: 0;
      left: 0;
      width: 1280px;
      height: 720px;
      background: rgba(0, 0, 0, 0.9);
      color: #fff;
      font-family: sans-serif;
      text-align: center;
      padding-top: 100px;
      z-index: 3;
    }
    #upgradeMenu button {
      padding: 10px 20px;
      font-size: 20px;
      cursor: pointer;
      margin: 10px;
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <div id="startScreen">
      <h1>Enhanced Browser Shooter</h1>
      <p>
        Protect your wall from waves of enemies!
      </p>
      <p>
        <strong>Controls:</strong><br>
        Click anywhere to shoot. A brief impact effect appears at the click position.<br>
        If the click is on an enemy, that enemy dies with a quick death effect (and you earn money).<br>
        Each shot consumes ammo (displayed as a bar with numbers).<br>
        Ammo reloads automatically when empty.
      </p>
      <p>
        Enemies approach from the left and, once they reach your wall, attack it with a punch-like animation.<br>
        If your wall’s health reaches 0, it's game over.<br>
        Earn money for each enemy kill, and after each day, purchase upgrades (for now, more ammo capacity).
      </p>
      <button id="startButton">Start Game</button>
    </div>
    <div id="upgradeMenu">
      <h1>Upgrade Menu</h1>
      <p id="moneyDisplay">Money: $0</p>
      <button id="buyAmmoUpgrade">Buy Ammo Upgrade (+5 max ammo) - $50</button><br>
      <button id="startNextDay">Start Next Day</button>
    </div>
    <canvas id="gameCanvas" width="1280" height="720"></canvas>
  </div>
  <script>
    // Canvas setup
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const startScreen = document.getElementById("startScreen");
    const startButton = document.getElementById("startButton");
    const upgradeMenu = document.getElementById("upgradeMenu");
    const moneyDisplay = document.getElementById("moneyDisplay");
    const buyAmmoUpgradeButton = document.getElementById("buyAmmoUpgrade");
    const startNextDayButton = document.getElementById("startNextDay");

    // Constants for canvas size and padding
    const CANVAS_WIDTH = 1280;
    const CANVAS_HEIGHT = 720;
    const PADDING = 50;

    // Game states: "menu", "transition", "running", "upgrade", "gameover", "win"
    let gameState = "menu";

    // Define the player (positioned behind the wall; used only for ammo display now)
    const player = {
      x: CANVAS_WIDTH - 150,
      y: CANVAS_HEIGHT / 2 - 40,
      width: 80,
      height: 80
    };

    // Define the wall (in front of the player)
    const wall = {
      x: CANVAS_WIDTH - 300,
      y: PADDING,
      width: 20,
      height: CANVAS_HEIGHT - 2 * PADDING,
      health: 100
    };

    // Ammo settings (ammo bar shown in top-left)
    let playerMaxAmmo = 10; // Upgradable value.
    let ammo = playerMaxAmmo;
    const reloadTime = 2000; // ms for full reload
    let isReloading = false;
    let reloadInterval = null;

    // Automatic reloading when ammo is 0
    function autoReload() {
      if (ammo <= 0 && !isReloading) {
        isReloading = true;
        const refillTime = reloadTime / playerMaxAmmo;
        reloadInterval = setInterval(() => {
          if (ammo < playerMaxAmmo) {
            ammo++;
          } else {
            clearInterval(reloadInterval);
            isReloading = false;
          }
        }, refillTime);
      }
    }

    // Shake effect when trying to shoot with no ammo
    let shakeTime = 0;
    function triggerShake() {
      shakeTime = 300; // ms
    }

    // Money system
    let money = 0;

    // Day/Wave system
    let day = 1;
    const maxDays = 5;
    let enemiesToSpawn = day * 5;
    let enemiesSpawned = 0;
    let transitionTimer = 0; // ms for day transition
    const transitionDuration = 2000; // ms
    let transitionMessage = "";

    // Function: count remaining enemies (to spawn + alive)
    function enemiesRemaining() {
      return (enemiesToSpawn - enemiesSpawned) + enemies.length;
    }

    // Arrays for enemies and impact effects (no bullets)
    let enemies = [];
    let impacts = [];

    // Impact effect settings
    const impactDuration = 300; // ms
    // Each impact effect: x, y, initial radius, max radius, duration, remainingTime

    // Enemy settings
    const enemySpeed = 0.8;
    let lastEnemySpawn = Date.now();

    // Attack cycle for enemy punch animation
    const attackCycle = 800; // ms per cycle
    const maxPunchRotation = 0.3; // radians

    // Enemy death effect duration
    const deathDuration = 300; // ms

    // Start Game: hide start screen and begin Day 1 transition.
    startButton.addEventListener("click", () => {
      startScreen.style.display = "none";
      startTransition();
    });

    // Upgrade menu event listeners
    buyAmmoUpgradeButton.addEventListener("click", () => {
      // Upgrade: increase max ammo by 5 for $50
      if (money >= 50) {
        money -= 50;
        playerMaxAmmo += 5;
        moneyDisplay.textContent = "Money: $" + money;
      }
    });
    startNextDayButton.addEventListener("click", () => {
      upgradeMenu.style.display = "none";
      // Increment day and start new transition.
      day++;
      startTransition();
    });

    // Shooting: when clicking, create an impact effect at the mouse.
    // If the click falls on an enemy, mark that enemy as dying.
    canvas.addEventListener("click", (e) => {
      if (gameState !== "running") return;
      if (isReloading || ammo <= 0) {
        if (ammo <= 0) triggerShake();
        return;
      }
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      let hitEnemy = null;
      for (let i = 0; i < enemies.length; i++) {
        const enemy = enemies[i];
        if (!enemy.dying &&
            mouseX >= enemy.x && mouseX <= enemy.x + enemy.width &&
            mouseY >= enemy.y && mouseY <= enemy.y + enemy.height) {
          hitEnemy = enemy;
          break;
        }
      }
      if (hitEnemy) {
        hitEnemy.dying = true;
        hitEnemy.deathTimer = deathDuration;
        money += 10; // Award money per kill.
      }
      // Create impact effect at click position.
      impacts.push({
        x: mouseX,
        y: mouseY,
        radius: 5,
        maxRadius: 20,
        duration: impactDuration,
        remainingTime: impactDuration
      });
      ammo--;
    });

    // Spawn an enemy from the left (within padded area)
    function spawnEnemy() {
      const enemyHeight = 40;
      const enemyY = Math.random() * (CANVAS_HEIGHT - 2 * PADDING - enemyHeight) + PADDING;
      enemies.push({
        x: PADDING - 50,
        y: enemyY,
        width: 40,
        height: enemyHeight,
        attacking: false,
        attackTimer: 0,
        rotation: 0,
        dying: false,
        deathTimer: 0
      });
      enemiesSpawned++;
    }

    // Start a day transition.
    function startTransition() {
      gameState = "transition";
      transitionTimer = transitionDuration;
      transitionMessage = "Day " + day;
      enemiesToSpawn = day * 5;
      enemiesSpawned = 0;
      enemies = [];
      impacts = [];
    }

    // Update impact effects.
    function updateImpacts(deltaTime) {
      impacts = impacts.filter(impact => {
        impact.remainingTime -= deltaTime;
        return impact.remainingTime > 0;
      });
    }

    // Draw impact effects.
    function drawImpacts() {
      impacts.forEach(impact => {
        const alpha = impact.remainingTime / impact.duration;
        const currentRadius = impact.radius + (impact.maxRadius - impact.radius) * (1 - alpha);
        ctx.fillStyle = `rgba(255,255,0,${alpha})`;
        ctx.beginPath();
        ctx.arc(impact.x, impact.y, currentRadius, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    // Update game state.
    function update(deltaTime) {
      if (gameState === "running") {
        autoReload();

        // Spawn enemies.
        if (enemiesSpawned < enemiesToSpawn) {
          if (Date.now() - lastEnemySpawn > 1500) {
            spawnEnemy();
            lastEnemySpawn = Date.now();
          }
        }

        // Update enemies.
        enemies.forEach((enemy, index) => {
          if (enemy.dying) {
            enemy.deathTimer -= deltaTime;
            enemy.x += (Math.random() - 0.5) * 2;
            enemy.y += (Math.random() - 0.5) * 2;
            if (enemy.deathTimer <= 0) {
              enemies.splice(index, 1);
            }
          } else {
            if (enemy.x + enemy.width < wall.x) {
              enemy.x += enemySpeed;
            } else {
              enemy.x = wall.x - enemy.width;
              enemy.attacking = true;
              enemy.attackTimer += deltaTime;
              enemy.rotation = maxPunchRotation * Math.sin(Math.PI * (enemy.attackTimer / attackCycle));
              if (enemy.attackTimer >= attackCycle) {
                wall.health -= 10;
                enemy.attackTimer = 0;
              }
            }
          }
        });

        // Advance to upgrade menu if wave is cleared.
        if (enemies.length === 0 && enemiesSpawned >= enemiesToSpawn) {
          if (day < maxDays) {
            gameState = "upgrade";
            moneyDisplay.textContent = "Money: $" + money;
            upgradeMenu.style.display = "block";
          } else {
            gameState = "win";
          }
        }
      } else if (gameState === "transition") {
        transitionTimer -= deltaTime;
        if (transitionTimer <= 0) {
          gameState = "running";
          ammo = playerMaxAmmo;
        }
      }

      if (shakeTime > 0) {
        shakeTime -= deltaTime;
        if (shakeTime < 0) shakeTime = 0;
      }

      if (wall.health <= 0) {
        gameState = "gameover";
      }

      updateImpacts(deltaTime);
    }

    // Draw game elements and UI.
    function draw() {
      ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

      if (gameState === "running" || gameState === "transition" || gameState === "upgrade") {
        // Draw the player (for ammo display) behind the wall.
        ctx.fillStyle = "#00AA00";
        ctx.fillRect(player.x, player.y, player.width, player.height);
        
        // Draw the wall.
        ctx.fillStyle = "#006400";
        ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
        ctx.fillStyle = "#FFFFFF";
        ctx.font = "18px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("Wall Health: " + Math.max(0, Math.floor(wall.health)), wall.x + wall.width / 2, wall.y - 10);
        
        // Draw enemies.
        enemies.forEach(enemy => {
          ctx.save();
          if (enemy.dying) {
            const offsetX = (Math.random() - 0.5) * 10;
            const offsetY = (Math.random() - 0.5) * 10;
            ctx.translate(enemy.x + enemy.width / 2 + offsetX, enemy.y + enemy.height / 2 + offsetY);
            ctx.fillStyle = "#FF0000";
            ctx.fillRect(-enemy.width / 2, -enemy.height / 2, enemy.width, enemy.height);
          } else if (enemy.attacking) {
            ctx.translate(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2);
            ctx.rotate(enemy.rotation);
            ctx.fillStyle = "#FF0000";
            ctx.fillRect(-enemy.width / 2, -enemy.height / 2, enemy.width, enemy.height);
          } else {
            ctx.fillStyle = "#FF0000";
            ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
          }
          ctx.restore();
        });
        
        // Draw impact effects.
        drawImpacts();
        
        // -- AMMO BAR SETTINGS --
const ammoBarWidth = 200;
const ammoBarHeight = 30;
const ammoBarX = 20;    // left margin
const ammoBarY = 20;    // top margin

// Draw ammo bar outline
ctx.strokeStyle = "#FFFFFF";
ctx.strokeRect(ammoBarX, ammoBarY, ammoBarWidth, ammoBarHeight);

// Fill proportionally
const ammoFillWidth = (ammo / playerMaxAmmo) * ammoBarWidth;
ctx.fillStyle = "#00FF00";
ctx.fillRect(ammoBarX, ammoBarY, ammoFillWidth, ammoBarHeight);

// Overlay ammo text
ctx.fillStyle = "#000000";
ctx.font = "20px sans-serif";
ctx.textAlign = "center";
ctx.fillText(
  ammo + " / " + playerMaxAmmo,
  ammoBarX + ammoBarWidth / 2,
  ammoBarY + ammoBarHeight - 5
);

// -- TEXT BELOW THE AMMO BAR --
// We'll place each line ~25 pixels below the previous line
let textY = ammoBarY + ammoBarHeight + 30; // start a bit below the ammo bar

ctx.fillStyle = "#FFFFFF";
ctx.font = "18px sans-serif";
ctx.textAlign = "left";

// Money
ctx.fillText("Money: $" + money, ammoBarX, textY);

// Day
textY += 25;
ctx.fillText("Day: " + day + " / " + maxDays, ammoBarX, textY);

// Enemies Remaining
textY += 25;
ctx.fillText("Enemies Remaining: " + enemiesRemaining(), ammoBarX, textY);
      }
      
      if (gameState === "transition") {
        ctx.fillStyle = "rgba(0,0,0,0.8)";
        ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        ctx.fillStyle = "#FFFFFF";
        ctx.font = "40px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText(transitionMessage, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);
      }
      
      if (gameState === "gameover") {
        ctx.fillStyle = "#FF0000";
        ctx.font = "40px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("GAME OVER", CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);
      } else if (gameState === "win") {
        ctx.fillStyle = "#00FF00";
        ctx.font = "40px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("YOU WIN!", CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);
      }
    }

    // Main game loop.
    let lastTime = 0;
    function gameLoop(timestamp) {
      const deltaTime = timestamp - lastTime;
      lastTime = timestamp;
      if (gameState !== "gameover" && gameState !== "win") {
        update(deltaTime);
      }
      draw();
      requestAnimationFrame(gameLoop);
    }

    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
