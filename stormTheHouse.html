<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Enhanced Browser Shooter – Defend Your Wall</title>
  <style>
    body { margin: 0; overflow: hidden; background: #222; }
    #gameContainer { position: relative; width: 1280px; margin: 0 auto; }
    canvas { display: block; background: #444; }
    #startScreen {
      position: absolute;
      top: 0;
      left: 0;
      width: 1280px;
      height: 720px;
      background: rgba(0, 0, 0, 0.85);
      color: #fff;
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 2;
      text-align: center;
      padding: 20px;
    }
    #startButton {
      padding: 10px 20px;
      font-size: 24px;
      cursor: pointer;
      margin-top: 20px;
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <div id="startScreen">
      <h1>Enhanced Browser Shooter</h1>
      <p>
        Protect your wall – your base – from waves of enemies!
      </p>
      <p>
        <strong>Controls:</strong><br>
        Click to shoot (if you have ammo).<br>
        Press Space to reload (ammo refills gradually).<br>
        Enemies approach from the left and will stop at your wall.<br>
        They then perform a punch-like attack with a slight delay. If your wall’s health reaches 0, it’s game over.
      </p>
      <button id="startButton">Start Game</button>
    </div>
    <canvas id="gameCanvas" width="1280" height="720"></canvas>
  </div>
  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const startScreen = document.getElementById("startScreen");
    const startButton = document.getElementById("startButton");

    // Constants for canvas and padding
    const CANVAS_WIDTH = 1280;
    const CANVAS_HEIGHT = 720;
    const PADDING = 50;

    // Game States: "menu", "transition", "running", "gameover", "win"
    let gameState = "menu";

    // The player's wall is our base:
    const wall = {
      x: CANVAS_WIDTH - 200,
      y: PADDING,
      width: 20,
      height: CANVAS_HEIGHT - 2 * PADDING,
      health: 100
    };

    // Ammo settings and visual fill (drawn inside a box above the wall)
    const maxAmmo = 10;
    let ammo = maxAmmo;
    const reloadTime = 2000; // total reload time in ms
    let isReloading = false;
    let reloadInterval = null; // for gradual refill
    let shakeTime = 0;  // shake timer (ms)

    // Day/Wave system
    let day = 1;
    const maxDays = 5;
    let enemiesToSpawn = day * 5;
    let enemiesSpawned = 0;
    let transitionTimer = 0;  // timer for day transition in ms
    const transitionDuration = 2000; // 2 seconds pause for day transition
    let transitionMessage = "";
    
    // Enemy remaining counter function
    function enemiesRemaining() {
      return (enemiesToSpawn - enemiesSpawned) + enemies.length;
    }

    // Arrays for bullets and enemies
    let bullets = [];
    let enemies = [];

    const bulletSpeed = 4;
    const enemySpeed = 0.8; // enemy movement speed

    let lastEnemySpawn = Date.now();

    // Attack cycle parameters for enemies (punch animation)
    const attackCycle = 800; // ms per attack cycle
    const maxPunchRotation = 0.3; // radians (~17 degrees)

    // For shake effect on wall when shooting without ammo
    function triggerShake() {
      shakeTime = 300; // shake for 300ms
    }

    // Start Game button click handler: hide start screen and start transition for Day 1.
    startButton.addEventListener("click", () => {
      startScreen.style.display = "none";
      startTransition();
    });

    // Listen for mouse clicks to shoot (only in running state)
    canvas.addEventListener("click", (e) => {
      if (gameState !== "running") return;
      if (isReloading || ammo <= 0) {
        if (ammo <= 0) triggerShake();
        return;
      }
      const rect = canvas.getBoundingClientRect();
      const clickX = e.clientX - rect.left;
      const clickY = e.clientY - rect.top;
      // Calculate angle from the center of the wall to the click point.
      const angle = Math.atan2(clickY - (wall.y + wall.height / 2), clickX - (wall.x + wall.width / 2));
      bullets.push({
        x: wall.x + wall.width / 2,
        y: wall.y + wall.height / 2,
        angle: angle
      });
      ammo--;
    });

    // Listen for spacebar to reload ammo gradually (one bullet every 200ms)
    window.addEventListener("keydown", (e) => {
      if (gameState !== "running") return;
      if (e.code === "Space" && !isReloading && ammo < maxAmmo) {
        isReloading = true;
        const refillTime = reloadTime / (maxAmmo - ammo);
        reloadInterval = setInterval(() => {
          if (ammo < maxAmmo) {
            ammo++;
          } else {
            clearInterval(reloadInterval);
            isReloading = false;
          }
        }, refillTime);
      }
    });

    // Function to spawn an enemy at a random vertical position on the left (within padded area)
    function spawnEnemy() {
      const enemyHeight = 40;
      const enemyY = Math.random() * (CANVAS_HEIGHT - 2 * PADDING - enemyHeight) + PADDING;
      enemies.push({
        x: PADDING - 50,  // start a little off-screen from left
        y: enemyY,
        width: 40,
        height: enemyHeight,
        attacking: false,
        attackTimer: 0, // timer for attack cycle
        rotation: 0
      });
      enemiesSpawned++;
    }

    // Start a day transition: fade to black with a day message.
    function startTransition() {
      gameState = "transition";
      transitionTimer = transitionDuration;
      transitionMessage = "Day " + day;
      // Reset enemy counts for the new day
      enemiesToSpawn = day * 5;
      enemiesSpawned = 0;
      enemies = [];
      bullets = [];
    }

    // Update game state
    function update(deltaTime) {
      if (gameState === "running") {
        // Update bullets: move and remove if out of bounds.
        bullets = bullets.filter(bullet => bullet.x < CANVAS_WIDTH && bullet.y > 0 && bullet.y < CANVAS_HEIGHT);
        bullets.forEach(bullet => {
          bullet.x += bulletSpeed * Math.cos(bullet.angle);
          bullet.y += bulletSpeed * Math.sin(bullet.angle);
        });

        // Spawn enemies until wave quota is reached.
        if (enemiesSpawned < enemiesToSpawn) {
          if (Date.now() - lastEnemySpawn > 1500) {
            spawnEnemy();
            lastEnemySpawn = Date.now();
          }
        }

        // Update enemies.
        enemies.forEach((enemy) => {
          // If enemy hasn't reached the wall yet, move forward.
          if (enemy.x + enemy.width < wall.x) {
            enemy.x += enemySpeed;
          } else {
            // Enemy reached the wall: begin attacking.
            enemy.attacking = true;
            enemy.attackTimer += deltaTime;
            // Calculate a punch rotation curve (sine wave) for visual effect.
            enemy.rotation = maxPunchRotation * Math.sin(Math.PI * (enemy.attackTimer / attackCycle));
            // When the attack cycle completes, deal damage and reset timer.
            if (enemy.attackTimer >= attackCycle) {
              wall.health -= 10;
              enemy.attackTimer = 0;
            }
          }
        });

        // Collision detection: if a bullet hits an enemy (only if enemy is not currently in its attack cycle, so you can shoot them down).
        bullets.forEach((bullet, bi) => {
          enemies.forEach((enemy, ei) => {
            if (
              bullet.x > enemy.x &&
              bullet.x < enemy.x + enemy.width &&
              bullet.y > enemy.y &&
              bullet.y < enemy.y + enemy.height
            ) {
              enemies.splice(ei, 1);
              bullets.splice(bi, 1);
            }
          });
        });

        // If wave is cleared, advance day if available.
        if (enemies.length === 0 && enemiesSpawned >= enemiesToSpawn) {
          if (day < maxDays) {
            day++;
            startTransition();
          } else {
            gameState = "win";
          }
        }
      } else if (gameState === "transition") {
        transitionTimer -= deltaTime;
        if (transitionTimer <= 0) {
          gameState = "running";
          ammo = maxAmmo; // reset ammo at start of new day
        }
      }

      // Update shake timer (for wall) if active.
      if (shakeTime > 0) {
        shakeTime -= deltaTime;
        if (shakeTime < 0) shakeTime = 0;
      }

      // Check for game over condition.
      if (wall.health <= 0) {
        gameState = "gameover";
      }
    }

    // Render game objects and UI.
    function draw() {
      // Clear canvas.
      ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

      // Draw game elements if in running or transition state.
      if (gameState === "running" || gameState === "transition") {
        // Calculate shake offset for the wall if active.
        let shakeOffset = 0;
        if (shakeTime > 0) {
          shakeOffset = (Math.random() - 0.5) * 10; // up to ±5px shake.
        }

        // Draw the wall as a dark green vertical line.
        ctx.fillStyle = "#006400";
        ctx.fillRect(wall.x + shakeOffset, wall.y, wall.width, wall.height);
        // Draw wall health above the wall.
        ctx.fillStyle = "#FFFFFF";
        ctx.font = "18px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("Wall Health: " + Math.max(0, Math.floor(wall.health)), wall.x + wall.width / 2, wall.y - 10);

        // Draw the ammo bar (inside a rectangle drawn above the wall).
        let ammoFillHeight = (ammo / maxAmmo) * wall.height;
        ctx.fillStyle = "rgba(0,255,0," + (ammo / maxAmmo) + ")";
        ctx.fillRect(wall.x + shakeOffset, wall.y + wall.height - ammoFillHeight, wall.width, ammoFillHeight);

        // Draw bullets (yellow circles).
        ctx.fillStyle = "#FFFF00";
        bullets.forEach(bullet => {
          ctx.beginPath();
          ctx.arc(bullet.x, bullet.y, 5, 0, Math.PI * 2);
          ctx.fill();
        });

        // Draw enemies.
        enemies.forEach(enemy => {
          ctx.save();
          // If enemy is attacking, apply its punch rotation.
          if (enemy.attacking) {
            ctx.translate(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2);
            ctx.rotate(enemy.rotation);
            ctx.translate(-enemy.width / 2, -enemy.height / 2);
          }
          ctx.fillStyle = "#FF0000";
          ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
          ctx.restore();
        });

        // Draw UI text in the top-left (within padded area).
        ctx.fillStyle = "#FFFFFF";
        ctx.font = "18px sans-serif";
        ctx.textAlign = "left";
        ctx.fillText("Wall Health: " + Math.max(0, Math.floor(wall.health)), 10, 30);
        ctx.fillText("Ammo: " + ammo + (isReloading ? " (Reloading...)" : ""), 10, 60);
        ctx.fillText("Day: " + day + " / " + maxDays, 10, 90);
        ctx.fillText("Enemies Remaining: " + enemiesRemaining(), 10, 120);
      }

      // Draw transition overlay if in transition state.
      if (gameState === "transition") {
        ctx.fillStyle = "rgba(0,0,0,0.8)";
        ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        ctx.fillStyle = "#FFFFFF";
        ctx.font = "40px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText(transitionMessage, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);
      }

      // Draw game over or win messages.
      if (gameState === "gameover") {
        ctx.fillStyle = "#FF0000";
        ctx.font = "40px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("GAME OVER", CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);
      } else if (gameState === "win") {
        ctx.fillStyle = "#00FF00";
        ctx.font = "40px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("YOU WIN!", CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);
      }
    }

    // Main game loop.
    let lastTime = 0;
    function gameLoop(timestamp) {
      const deltaTime = timestamp - lastTime;
      lastTime = timestamp;
      if (gameState !== "gameover" && gameState !== "win") {
        update(deltaTime);
      }
      draw();
      requestAnimationFrame(gameLoop);
    }

    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
