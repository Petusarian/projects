<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Enhanced Browser Shooter with Transitions</title>
  <style>
    body { margin: 0; overflow: hidden; background: #222; }
    #gameContainer { position: relative; width: 800px; margin: 0 auto; }
    canvas { display: block; background: #444; }
    #startButton {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 20px 40px;
      font-size: 24px;
      cursor: pointer;
      z-index: 2;
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <button id="startButton">Start Game</button>
    <canvas id="gameCanvas" width="800" height="400"></canvas>
  </div>
  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const startButton = document.getElementById("startButton");

    // Game States: "menu", "transition", "running", "gameover", "win"
    let gameState = "menu";

    // Base settings
    let baseHealth = 100;
    const baseMaxHealth = 100;
    const base = {
      x: canvas.width - 100,
      y: canvas.height / 2 - 40,
      width: 80,
      height: 80,
      shakeOffset: 0
    };

    // Ammo settings and visual fill
    const maxAmmo = 10;
    let ammo = maxAmmo;
    const reloadTime = 2000; // ms
    let isReloading = false;
    let shakeTime = 0;  // shake timer in ms

    // Day/Wave system
    let day = 1;
    const maxDays = 5;
    let enemiesToSpawn = day * 5;
    let enemiesSpawned = 0;
    let transitionTimer = 0;  // timer for day transition (in ms)
    const transitionDuration = 2000; // 2 seconds pause for day transition
    let transitionAlpha = 1; // for fade effect

    // Bullet and enemy arrays
    let bullets = [];
    let enemies = [];

    const bulletSpeed = 4;
    const enemySpeed = 0.8; // slower enemy movement

    let lastEnemySpawn = Date.now();

    // Variables for transition fade effect
    let transitionMessage = "";

    // For shake effect: if no ammo and player tries to shoot
    function triggerShake() {
      shakeTime = 300; // shake for 300ms
    }

    // Start Game button click handler
    startButton.addEventListener("click", () => {
      startButton.style.display = "none";
      startTransition(); // start with Day 1 transition
    });

    // Listen for mouse clicks to shoot (only in running state)
    canvas.addEventListener("click", (e) => {
      if (gameState !== "running") return;
      if (isReloading || ammo <= 0) {
        if (ammo <= 0) triggerShake();
        return;
      }
      const rect = canvas.getBoundingClientRect();
      const clickX = e.clientX - rect.left;
      const clickY = e.clientY - rect.top;
      const angle = Math.atan2(clickY - (base.y + base.height / 2), clickX - (base.x + base.width / 2));
      bullets.push({
        x: base.x + base.width / 2,
        y: base.y + base.height / 2,
        angle: angle
      });
      ammo--;
    });

    // Listen for spacebar to reload ammo
    window.addEventListener("keydown", (e) => {
      if (gameState !== "running") return;
      if (e.code === "Space" && !isReloading && ammo < maxAmmo) {
        isReloading = true;
        setTimeout(() => {
          ammo = maxAmmo;
          isReloading = false;
        }, reloadTime);
      }
    });

    // Function to spawn an enemy at a random vertical position on the left
    function spawnEnemy() {
      enemies.push({
        x: -50,
        y: Math.random() * (canvas.height - 40),
        width: 40,
        height: 40
      });
      enemiesSpawned++;
    }

    // Function to start a day transition
    function startTransition() {
      gameState = "transition";
      transitionTimer = transitionDuration;
      transitionMessage = "Day " + day;
      // Reset enemy spawn counts for the new day
      enemiesToSpawn = day * 5;
      enemiesSpawned = 0;
      // Clear any leftover enemies/bullets if needed
      enemies = [];
      bullets = [];
    }

    // Update game state
    function update(deltaTime) {
      if (gameState === "running") {
        // Update bullets: move and remove if out of bounds
        bullets = bullets.filter(bullet => bullet.x < canvas.width && bullet.y > 0 && bullet.y < canvas.height);
        bullets.forEach(bullet => {
          bullet.x += bulletSpeed * Math.cos(bullet.angle);
          bullet.y += bulletSpeed * Math.sin(bullet.angle);
        });

        // Spawn enemies until the wave quota is reached
        if (enemiesSpawned < enemiesToSpawn) {
          if (Date.now() - lastEnemySpawn > 1500) {
            spawnEnemy();
            lastEnemySpawn = Date.now();
          }
        }

        // Update enemies: move them toward the base
        enemies.forEach((enemy, index) => {
          enemy.x += enemySpeed;
          // If enemy reaches the base, damage the base
          if (enemy.x + enemy.width > base.x) {
            baseHealth -= 10;  // each enemy does 10 damage
            enemies.splice(index, 1);
          }
        });

        // Collision detection: bullet hits enemy
        bullets.forEach((bullet, bi) => {
          enemies.forEach((enemy, ei) => {
            if (bullet.x > enemy.x && bullet.x < enemy.x + enemy.width &&
                bullet.y > enemy.y && bullet.y < enemy.y + enemy.height) {
              enemies.splice(ei, 1);
              bullets.splice(bi, 1);
            }
          });
        });

        // If wave is cleared and no more enemies are coming, advance day/wave
        if (enemies.length === 0 && enemiesSpawned >= enemiesToSpawn) {
          if (day < maxDays) {
            day++;
            startTransition();
          } else {
            gameState = "win";
          }
        }
      } else if (gameState === "transition") {
        // Count down the transition timer
        transitionTimer -= deltaTime;
        if (transitionTimer <= 0) {
          gameState = "running";
          // Reset ammo on new day if desired
          ammo = maxAmmo;
        }
      }

      // Update shake timer for base if active
      if (shakeTime > 0) {
        shakeTime -= deltaTime;
        if (shakeTime < 0) shakeTime = 0;
      }
    }

    // Render game objects and UI
    function draw() {
      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw game elements only if game not in menu
      if (gameState === "running" || gameState === "transition") {
        // Draw base with possible shake offset
        let shakeOffset = 0;
        if (shakeTime > 0) {
          shakeOffset = (Math.random() - 0.5) * 10; // shake magnitude up to 5 pixels left/right
        }
        // Draw base (player) as a rectangle
        ctx.fillStyle = "#00AA00";
        ctx.fillRect(base.x + shakeOffset, base.y, base.width, base.height);

        // Draw ammo fill inside the base
        // Calculate fill height proportional to ammo left
        let ammoFillHeight = (ammo / maxAmmo) * base.height;
        // Set fill opacity proportional to ammo (full ammo = full opacity)
        ctx.fillStyle = "rgba(0,255,0," + (ammo / maxAmmo) + ")";
        ctx.fillRect(base.x + shakeOffset, base.y + base.height - ammoFillHeight, base.width, ammoFillHeight);

        // Draw bullets (yellow circles)
        ctx.fillStyle = "#FFFF00";
        bullets.forEach(bullet => {
          ctx.beginPath();
          ctx.arc(bullet.x, bullet.y, 5, 0, Math.PI * 2);
          ctx.fill();
        });

        // Draw enemies (red squares)
        ctx.fillStyle = "#FF0000";
        enemies.forEach(enemy => {
          ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
        });

        // Draw UI: base health, ammo, and day info
        ctx.fillStyle = "#FFFFFF";
        ctx.font = "18px sans-serif";
        ctx.fillText("Base Health: " + baseHealth, 20, 30);
        ctx.fillText("Ammo: " + ammo + (isReloading ? " (Reloading...)" : ""), 20, 60);
        ctx.fillText("Day: " + day + " / " + maxDays, 20, 90);
      }

      // Draw transition overlay if in transition state
      if (gameState === "transition") {
        // Fade effect: we can simply draw a black rectangle over everything.
        ctx.fillStyle = "rgba(0,0,0,0.8)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#FFFFFF";
        ctx.font = "40px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText(transitionMessage, canvas.width / 2, canvas.height / 2);
      }

      // Draw game over or win messages
      if (baseHealth <= 0) {
        ctx.fillStyle = "#FF0000";
        ctx.font = "40px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("GAME OVER", canvas.width / 2, canvas.height / 2);
      } else if (gameState === "win") {
        ctx.fillStyle = "#00FF00";
        ctx.font = "40px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("YOU WIN!", canvas.width / 2, canvas.height / 2);
      }
    }

    // Main game loop variables
    let lastTime = 0;
    function gameLoop(timestamp) {
      const deltaTime = timestamp - lastTime;
      lastTime = timestamp;
      if (baseHealth > 0 && gameState !== "win") {
        update(deltaTime);
      }
      draw();
      requestAnimationFrame(gameLoop);
    }

    // Start the game loop
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
